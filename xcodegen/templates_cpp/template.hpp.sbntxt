/**********************************************************************************************************************************
*
*		File: {{outputfilename}}
*		Date: {{currentdate}}
*
*		This file was autogenerated using the xcode code generator.
*		Every addition to this file will be overwritten when new code is generated using the code generator.
*
*		Note: This code should only use packets with a maxsize known at compile time. So you can excpect that the GetMaxSize
*		      Memberfunction works on every packet in this file.
*
**********************************************************************************************************************************/

#ifndef USE_ETL
#define USE_ETL //Force etl to be bundeled with BaseCom because strings in this template need the etl::string implementation
#endif

#include <cstdint>
#include "BaseCom.hpp"
#include "etl/string.h"

#ifndef XCM_DEFINITIONS_HPP__
#define XCM_DEFINITIONS_HPP__

using namespace translib;

{{~

func createDataType(entry)
	if entry.internaltype | string.downcase == "string"
		if entry.length == 1
			ret entry.typename
		else
			ret "etl::string<" + entry.length + ">"
		end
	else
		ret entry.typename
	end
end

func generateSymbolName(message,symbol)
	if !symbol.anonymous && !symbol.global
		ret message.name + "_" + symbol.name
	else
		ret symbol.name
	end
end

func generateSymbolParameterList(symbol, symbolcount, symbolssize, split)
		$line = ""
		if symbol.anonymous || split
			for entry in symbol.entries
				$line = $line + createDataType entry
				if !for.last && (symbolcount == 0 || ((symbolcount + 1) < symbolssize))
					$line = $line + ", "
				end
			end
		else
			$line = $line + generateSymbolName message symbol
		end
		ret $line
end

func generateTemplateParameterListEntry(message)
	$line = ""
	for symbol in message.symbols
		$line = $line + generateSymbolParameterList symbol for.index message.symbols.size false
		if !for.last
			$line = $line + ", "
		end
	end
	ret $line
end

-}}
//{ Region MessageDefinitions
{{~for message in messages}}
/********************************************************************************************************
Definitions for {{message.name}}
{{for line in message.description}}
{{line}}
{{-end-}}
********************************************************************************************************/
//{ Region {{message.name | string.upcase}}
{{-for symbol in message.symbols}}
{{if !(symbol.name | string.whitespace)}}//{ Region {{symbol.name}}
	{{~if !symbol.anonymous && !symbol.global}}
		{{-for line in symbol.description}}
			{{~}}//{{line}}
		{{~end-}}
		{{-if symbol.isbitfield-}}
			{{~}}struct {{generateSymbolName message symbol}} : public Bitfield<{{symbol.length * 8}}>
			{{~}}{
				{{-$offset = 0}}
				{{-for entry in symbol.entries}}
					{{~}}	static const size_t {{entry.name}}_Offset = {{$offset}};
					{{~}}	static const size_t {{entry.name}}_Length = {{entry.bitlength}};
					{{-$offset = $offset + entry.bitlength-}}
				{{-end}}

				{{~for entry in symbol.entries}}
					{{~}}	{{createDataType entry}} Read_{{entry.name}}()
					{{~}}	{
					{{~}}		return GetData<{{createDataType entry}}>({{entry.name}}_Offset, {{entry.name}}_Length);
					{{~}}	}
					{{~}}	void Write_{{entry.name}}({{createDataType entry}} data)
					{{~}}	{
					{{~}}		return WriteData({{entry.name}}_Offset, {{entry.name}}_Length, data);
					{{~}}	}
				{{-end}}
			{{~}}};
		{{-else}}
			{{~}}struct {{generateSymbolName message symbol}} : public ComPacket<{{generateSymbolParameterList symbol 0 message.symbols.size true}}>
			{{~}}{
				{{-for entry in symbol.entries}}
				{{~}}	{{createDataType entry}}& {{entry.name | string.downcase}} = get<{{for.index}}>(elements);
				{{-end}}
			{{~}}};
		{{-end-}}
	{{-end}}
//}{{end}}
{{-end}}
struct {{message.name}} : public ComPacket<{{generateTemplateParameterListEntry message}}>
{
	{{~if message.idisstring}}
	{{~}}	const char* id = "{{message.idstring}}";
	{{-end}}
	static constexpr std::array<uint8_t, {{message.idbytelength}}> idBytes = { {{message.idbyte | array.join ","}} };
	static constexpr size_t packetLength = {{message.idbytelength}} + GetMaxSize();
	{{-for symbol in message.symbols}}
		{{-if !symbol.global && symbol.anonymous}}
			{{-for entry in symbol.entries}}
			{{~}}	{{createDataType entry}}& {{entry.name | string.downcase}} = get<{{for.index}}>(elements);
			{{-end}}
		{{-else}}
			{{~}}	{{generateSymbolName message symbol}}& {{symbol.name | string.downcase}} = get<{{for.index}}>(elements);
		{{-end}}
	{{-end}}

	/**
	* @brief Checks if the id in data matches the id of this packet.
	*
	* If this function returns a match it used exactly idbytelength of bytes
	*
	* @tparam maxdatalength 
    * @param data 
    * @param length 
    * @return tuple<bool, size_t, size_t> If the packet start matches the id; The offset to the packet start; The remaining bytes in the packet.
	**/
	template<const size_t maxdatalength>
	static tuple<bool, size_t, size_t> IDMatch(const std::array<uint8_t, maxdatalength> &data,const size_t length)
	{
		assert(length <= maxdatalength);
		if(length <= maxdatalength)
		{
			auto [valid, iterator, remainingBytes] = CheckIDMatch(data, length, idBytes);
			auto dist = std::distance(data.begin(), iterator);
			assert(dist >= 0);
			return make_tuple(valid, dist, remainingBytes);
		}
		else
		{
			return make_tuple(false, 0, length);
		}
	}

#ifdef USE_MEMALLOC
	/**
    * @brief Serialize the packet to an newly created vector with the specified id data before the serialized data.
    * 
    * @return unique_ptr<vector<uint8_t>> 
    */
    unique_ptr<vector<uint8_t>> SerializeWithID() const
    {
		return Serialize(idBytes);
	}
#endif

	/**
    * @brief Serialize the packet to the buffer starting at begin and ending on end.
    *
    * @tparam datalength
    * @param buffer - The array to hold the data
    * @return size_t - Byte length of the serialized data
    */
    template <const size_t datalength>
    size_t SerializeWithID(array<uint8_t, datalength> &buffer) const
    {
        return Serialize(buffer, idBytes);
    }

	/**
    * @brief Serialize the packet and returns the length of the serialized data and the data itself.
    *
    * @return std::tuple<size_t, std::array<uint8_t, packetLength>> Datalength; The data of the packet.
    */
	std::tuple<size_t, std::array<uint8_t, packetLength>> SerializeWithID() const
	{
		std::array<uint8_t, packetLength> data;
		size_t datalength = SerializeWithID(data);
		return std::make_tuple(datalength, data);
	}
};
//}
/********************************************************************************************************/

{{~end-}}
enum class Messages
{
	{{~for message in messages-}}
	{{~}}	{{message.name}},
	{{~end~}}
	Unkown
};

template<Messages message> struct get_message;
{{~for message in messages-}}
	{{~}}template<> struct get_message<Messages::{{message.name}}>{ typedef {{message.name}} type;};
{{~end~}}

template<const size_t maxdatalength>
auto GetMatchedMessage(const std::array<uint8_t, maxdatalength> &data, size_t length)
{
	std::tuple<bool, size_t, size_t> ret;
	{{~for message in messages-}}
	{{~}}	if(std::get<0>(ret = {{message.name}}::IDMatch(data, length))) return std::make_tuple(Messages::{{message.name}}, std::get<1>(ret), std::get<2>(ret));
	{{~end~}}
	return std::make_tuple(Messages::Unkown, 0U, 0U);
}
//}

//{ Region CommandDefinitions
{{~for message in commands}}
/********************************************************************************************************
Definitions for {{message.name}}
{{for line in message.description}}
{{line}}
{{-end-}}
********************************************************************************************************/
//{ Region {{message.name | string.upcase}}
{{-for symbol in message.symbols}}
{{if !(symbol.name | string.whitespace)}}//{ Region {{symbol.name}}
	{{~if !symbol.anonymous && !symbol.global}}
			{{-for line in symbol.description}}
				{{~}}//{{line}}
			{{~end-}}
		{{-if symbol.isbitfield-}}
			{{~}}struct {{generateSymbolName message symbol}} : public Bitfield<{{symbol.length * 8}}>
			{{~}}{
				{{-$offset = 0}}
				{{-for entry in symbol.entries}}
					{{~}}	static const size_t {{entry.name}}_Offset = {{$offset}};
					{{~}}	static const size_t {{entry.name}}_Length = {{entry.bitlength}};
					{{-$offset = $offset + entry.bitlength-}}
				{{-end}}

				{{~for entry in symbol.entries}}
					{{~}}	{{createDataType entry}} Read_{{entry.name}}()
					{{~}}	{
					{{~}}		return GetData<{{createDataType entry}}>({{entry.name}}_Offset, {{entry.name}}_Length);
					{{~}}	}
					{{~}}	void Write_{{entry.name}}({{createDataType entry}} data)
					{{~}}	{
					{{~}}		return WriteData({{entry.name}}_Offset, {{entry.name}}_Length, data);
					{{~}}	}
				{{-end}}
			{{~}}};
		{{-else}}
			{{~}}struct {{generateSymbolName message symbol}} : public ComPacket<{{generateSymbolParameterList symbol 0 message.symbols.size true}}>
			{{~}}{
				{{-for entry in symbol.entries}}
				{{~}}	{{createDataType entry}}& {{entry.name | string.downcase}} = get<{{for.index}}>(elements);
				{{-end}}
			{{~}}};
		{{-end-}}
	{{-end}}
//}{{end}}
{{-end}}
struct {{message.name}} : public ComPacket<{{generateTemplateParameterListEntry message}}>
{
	{{~if message.idisstring}}
	{{~}}	const char* id = "{{message.idstring}}";
	{{-end}}
	static constexpr size_t idbytelength = {{message.idbytelength}};
	static constexpr std::array<uint8_t, idbytelength> idBytes = { {{message.idbyte | array.join ","}} };
	static constexpr size_t packetLength = idbytelength + GetMaxSize();
	{{-for symbol in message.symbols}}
		{{-if !symbol.global && symbol.anonymous}}
			{{-for entry in symbol.entries}}
			{{~}}	{{createDataType entry}}& {{entry.name | string.downcase}} = get<{{for.index}}>(elements);
			{{-end}}
		{{-else}}
			{{~}}	{{generateSymbolName message symbol}}& {{symbol.name | string.downcase}} = get<{{for.index}}>(elements);
		{{-end}}
	{{-end}}

	/**
	* @brief Checks if the id in data matches the id of this packet.
	*
	* If this function returns a match it used exactly idbytelength of bytes
	*
	* @tparam maxdatalength 
    * @param data 
    * @param length 
    * @return tuple<bool, size_t, size_t> If the packet start matches the id; The offset to the packet start; The remaining bytes in the packet.
	**/
	template<const size_t maxdatalength>
	static tuple<bool, size_t, size_t> IDMatch(const std::array<uint8_t, maxdatalength> &data,const size_t length)
	{
		assert(length <= maxdatalength);
		if(length <= maxdatalength)
		{
			auto [valid, iterator, remainingBytes] = CheckIDMatch(data, length, idBytes);
			auto dist = std::distance(data.begin(), iterator);
			assert(dist >= 0);
			return make_tuple(valid, dist, remainingBytes);
		}
		else
		{
			return make_tuple(false, 0, length);
		}
	}

#ifdef USE_MEMALLOC
	/**
    * @brief Serialize the packet to an newly created vector with the specified id data before the serialized data.
    * 
    * @return unique_ptr<vector<uint8_t>> 
    */
    unique_ptr<vector<uint8_t>> SerializeWithID() const
    {
		return Serialize(idBytes);
	}
#endif

	/**
    * @brief Serialize the packet to the buffer starting at begin and ending on end.
    *
    * @tparam datalength
    * @param buffer - The array to hold the data
    * @return size_t - Byte length of the serialized data
    */
    template <const size_t datalength>
    size_t SerializeWithID(array<uint8_t, datalength> &buffer) const
    {
        return Serialize(buffer, idBytes);
    }

	/**
    * @brief Serialize the packet and returns the length of the serialized data and the data itself.
    *
    * @return std::tuple<size_t, std::array<uint8_t, packetLength>> Datalength; The data of the packet.
    */
	std::tuple<size_t, std::array<uint8_t, packetLength>> SerializeWithID() const
	{
		std::array<uint8_t, packetLength> data;
		size_t datalength = SerializeWithID(data);
		return std::make_tuple(datalength, data);
	}
};
//}
/********************************************************************************************************/

{{~end-}}
enum class Commands
{
	{{~for message in commands-}}
	{{~}}	{{message.name}},
	{{~end~}}
	Unkown
};

template<Commands message> struct get_command;
{{~for message in commands-}}
	{{~}}template<> struct get_command<Commands::{{message.name}}>{ typedef {{message.name}} type;};
{{~end~}}

template<const size_t maxdatalength>
auto GetMatchedCommand(const std::array<uint8_t, maxdatalength> &data, size_t length)
{
	std::tuple<bool, size_t, size_t> ret;
	{{~for message in commands-}}
	{{~}}	if(std::get<0>(ret = {{message.name}}::IDMatch(data, length))) return std::make_tuple(Commands::{{message.name}}, std::get<1>(ret), std::get<2>(ret));
	{{~end~}}
	return std::make_tuple(Commands::Unkown, 0U, 0U);
}
//}
#endif